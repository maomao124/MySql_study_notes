# ---MySql学习笔记---

by mao

# 事务

###  概念

是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

###  查看/设置事务提交方式

```sql
select @@autocommit;

set @@autocommit=0;
```



### 提交事务

commit;

### 回滚事务

rollback;



### 开启事务

```sql
START TRANSACTION 或 BEGIN ;
```



## 事务四大特性 ,简称ACID。

* 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
*  一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
*  隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。
*  持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。



## 并发事务问题

* 赃读：一个事务读到另外一个事务还没有提交的数据。比如B读取到了A未提交的数据。
*  不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。事务A两次读取同一条记录，但是读取到的数据却是不一样的
* 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。



## 事务的隔离级别

Read uncommitted、Read committed、Repeatable Read(默认)、Serializable

* Read uncommitted：未解决赃读、不可重复读和幻读问题
* Read committed：解决赃读问题
* Repeatable Read： 解决赃读和不可重复读问题
* Serializable：解决赃读、不可重复读和幻读问题



### 查看事务隔离级别

```sql
SELECT @@TRANSACTION_ISOLATION;
```



### 设置事务隔离级别

```sql
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |
READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```



事务隔离级别越高，数据越安全，但是性能越低。Serializable级别最高，Read uncommitted级别最低。



# 存储引擎



## MySQL体系结构

* 连接层 ：最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 
* 服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。 
* 引擎层 ：存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。
* 存储层：数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。



## 建表时指定存储引擎

```sql
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```



## 查询当前数据库支持的存储引擎

```sql
show engines;
```





## 存储引擎特点

### InnoDB

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。



#### 特点：

* DML操作遵循ACID模型，支持事务；
* 行级锁，提高并发访问性能；
* 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；



#### 文件:

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。



#### 逻辑存储结构:

* 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。
* 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
* 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 
* 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 
* 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。





### MyISAM



MyISAM是MySQL早期的默认存储引擎。



#### 特点 

* 不支持事务
* 不支持外键 
* 支持表锁
* 不支持行锁 
* 访问速度快



#### 文件

* xxx.sdi：存储表结构信息 
* xxx.MYD: 存储数据 
* xxx.MYI: 存储索引



### Memory



Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。



 #### 特点 

* 内存存放 
* hash索引（默认）



#### 文件 

* xxx.sdi：存储表结构信息



### 特点



```sql
特点 InnoDB 	MyISAM 	Memory
存储限制 64TB	 有 	有
事务安全 支持		 - 	-
锁机制 行锁	 表锁	 表锁
B+tree索引 支持 支持 支持
Hash索引 - 	- 	支持
全文索引 支持(5.6版本之后) 支持 -
空间使用 高 	低 	N/A
内存使用 高 	低 	中等
批量插入速度 低 	高	 高
支持外键 支持	 -	 -
```



### 存储引擎选择



* InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。
* MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
* MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。







# 索引



## 介绍

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。



## 特点



### 优势

* 提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消耗。



### 劣势

* 索引列也是要占用空间的
* 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。



## 索引结构



MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构

* B+Tree索引：最常见的索引类型，大部分引擎都支持 B+ 树索引
* Hash索引：底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询
* R-tree(空间索 引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
* Full-text(全文 索引) ：是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES



## 索引结构支持情况



<h3>从左到右分别为 InnoDB， MyISAM， Memory</h3>

* B+tree索引 ：支持  支持  支持
* Hash 索引 ：不支持  不支持  支持
* R-tree 索引 ：不支持  支持  不支持
* Full-text： 5.6版本之后支持   支持   不支持



MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。



## 为什么InnoDB存储引擎选择使用B+tree索引结构？

* 相对于二叉树，层级更少，搜索效率高
*  对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
* 相对Hash索引，B+tree支持范围匹配及排序操作





## 索引分类

* 主键索引： 针对于表中主键创建的索引，默认自动创建, 只能 有一个
* 唯一索引：避免同一个表中某数据列中的值重复 ，可以有多个 
* 常规 索引：快速定位特定数据 ，可以有多个 
* 全文 索引：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个 



### 聚集索引&二级索引

* 聚集索引(Clustered Index)： 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据：必须有,而且只 有一个
* 二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键：可以存在多个



#### 聚集索引选取规则

* 如果存在主键，主键索引就是聚集索引
* 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引



####  区别

* 聚集索引的叶子节点下挂的是这一行的数据
* 二级索引的叶子节点下挂的是该字段值对应的主键值



### 回表查询

先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询





## 索引使用

### 创建索引

```sq
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (
index_col_name,... );
```

###  查看索引

```sql
SHOW INDEX FROM table_name;
```

###  删除索引

```sql
DROP INDEX index_name ON table_name;
```





# SQL性能分析



## SQL执行频率

查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次

### 语法

```sql
 show [session|global] status
```

* session 是查看当前会话
* global 是查询全局数据



SHOW GLOBAL STATUS LIKE 'Com_______';

* Com_delete: 删除次数
* Com_insert: 插入次数
* Com_select: 查询次数
* Com_update: 更新次数

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。



## 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。

MySQL的慢查询日志默认没有开启

###  开启

如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```



## profile详情

show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作

```sql
SELECT @@have_profiling ;
```



