# ---MySql学习笔记---

by mao

# 事务

###  概念

是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

###  查看/设置事务提交方式

```sql
select @@autocommit;

set @@autocommit=0;
```



### 提交事务

commit;

### 回滚事务

rollback;



### 开启事务

```sql
START TRANSACTION 或 BEGIN ;
```



## 事务四大特性 ,简称ACID。

* 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
*  一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
*  隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。
*  持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。



## 并发事务问题

* 赃读：一个事务读到另外一个事务还没有提交的数据。比如B读取到了A未提交的数据。
*  不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。事务A两次读取同一条记录，但是读取到的数据却是不一样的
* 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。



## 事务的隔离级别

Read uncommitted、Read committed、Repeatable Read(默认)、Serializable

* Read uncommitted：未解决赃读、不可重复读和幻读问题
* Read committed：解决赃读问题
* Repeatable Read： 解决赃读和不可重复读问题
* Serializable：解决赃读、不可重复读和幻读问题



### 查看事务隔离级别

```sql
SELECT @@TRANSACTION_ISOLATION;
```



### 设置事务隔离级别

```sql
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |
READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```



事务隔离级别越高，数据越安全，但是性能越低。Serializable级别最高，Read uncommitted级别最低。



# 存储引擎



## MySQL体系结构

* 连接层 ：最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 
* 服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。 
* 引擎层 ：存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。
* 存储层：数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。



## 建表时指定存储引擎

```sql
CREATE TABLE 表名(
字段1 字段1类型 [ COMMENT 字段1注释 ] ,
......
字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;
```



## 查询当前数据库支持的存储引擎

```sql
show engines;
```





## 存储引擎特点

### InnoDB

InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。



#### 特点：

* DML操作遵循ACID模型，支持事务；
* 行级锁，提高并发访问性能；
* 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；



#### 文件:

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。



#### 逻辑存储结构:

* 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。
* 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。
* 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 
* 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 
* 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。





### MyISAM



MyISAM是MySQL早期的默认存储引擎。



#### 特点 

* 不支持事务
* 不支持外键 
* 支持表锁
* 不支持行锁 
* 访问速度快



#### 文件

* xxx.sdi：存储表结构信息 
* xxx.MYD: 存储数据 
* xxx.MYI: 存储索引



### Memory



Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。



 #### 特点 

* 内存存放 
* hash索引（默认）



#### 文件 

* xxx.sdi：存储表结构信息



### 特点



```sql
特点 InnoDB 	MyISAM 	Memory
存储限制 64TB	 有 	有
事务安全 支持		 - 	-
锁机制 行锁	 表锁	 表锁
B+tree索引 支持 支持 支持
Hash索引 - 	- 	支持
全文索引 支持(5.6版本之后) 支持 -
空间使用 高 	低 	N/A
内存使用 高 	低 	中等
批量插入速度 低 	高	 高
支持外键 支持	 -	 -
```



### 存储引擎选择



* InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。
* MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
* MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。







# 索引



## 介绍

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。



## 特点



### 优势

* 提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消耗。



### 劣势

* 索引列也是要占用空间的
* 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。



## 索引结构



MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构

* B+Tree索引：最常见的索引类型，大部分引擎都支持 B+ 树索引
* Hash索引：底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询
* R-tree(空间索 引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少
* Full-text(全文 索引) ：是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES



## 索引结构支持情况



<h3>从左到右分别为 InnoDB， MyISAM， Memory</h3>

* B+tree索引 ：支持  支持  支持
* Hash 索引 ：不支持  不支持  支持
* R-tree 索引 ：不支持  支持  不支持
* Full-text： 5.6版本之后支持   支持   不支持



MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。

在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。



## 为什么InnoDB存储引擎选择使用B+tree索引结构？

* 相对于二叉树，层级更少，搜索效率高
*  对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
* 相对Hash索引，B+tree支持范围匹配及排序操作





## 索引分类

* 主键索引： 针对于表中主键创建的索引，默认自动创建, 只能 有一个
* 唯一索引：避免同一个表中某数据列中的值重复 ，可以有多个 
* 常规 索引：快速定位特定数据 ，可以有多个 
* 全文 索引：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个 



### 聚集索引&二级索引

* 聚集索引(Clustered Index)： 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据：必须有,而且只 有一个
* 二级索引(Secondary Index)：将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键：可以存在多个



#### 聚集索引选取规则

* 如果存在主键，主键索引就是聚集索引
* 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引



####  区别

* 聚集索引的叶子节点下挂的是这一行的数据
* 二级索引的叶子节点下挂的是该字段值对应的主键值



### 回表查询

先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询





## 索引使用

### 创建索引

```sq
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (
index_col_name,... );
```

###  查看索引

```sql
SHOW INDEX FROM table_name;
```

###  删除索引

```sql
DROP INDEX index_name ON table_name;
```





# SQL性能分析



## SQL执行频率

查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次

### 语法

```sql
 show [session|global] status
```

* session 是查看当前会话
* global 是查询全局数据



SHOW GLOBAL STATUS LIKE 'Com_______';

* Com_delete: 删除次数
* Com_insert: 插入次数
* Com_select: 查询次数
* Com_update: 更新次数

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。



## 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。

MySQL的慢查询日志默认没有开启

###  开启

如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```



## profile详情

show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作

```sql
SELECT @@have_profiling ;
```



session/global级别开启profiling：

```sql
SET profiling = 1;
```



查看每一条SQL的耗时基本情况：

```sql
show profiles;
```



```sh
mysql> SET profiling = 1;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> explain select count(*) from tb_hotel
    -> ;
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | tb_hotel | NULL       | index | NULL          | PRIMARY | 8       | NULL |  201 |   100.00 | Using index |
+----+-------------+----------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql>  select count(*) from tb_hotel
    -> ;
+----------+
| count(*) |
+----------+
|      201 |
+----------+
1 row in set (0.00 sec)

mysql> show profiles;
+----------+------------+---------------------------------------+
| Query_ID | Duration   | Query                                 |
+----------+------------+---------------------------------------+
|        1 | 0.00086325 | explain select count(*) from tb_hotel |
|        2 | 0.00165000 | select count(*) from tb_hotel         |
+----------+------------+---------------------------------------+
2 rows in set, 1 warning (0.00 sec)

mysql>
```



```sh
mysql> show profiles;
+----------+------------+-------------------------------------------------------------+
| Query_ID | Duration   | Query                                                       |
+----------+------------+-------------------------------------------------------------+
|        1 | 0.00086325 | explain select count(*) from tb_hotel                       |
|        2 | 0.00165000 | select count(*) from tb_hotel                               |
|        3 | 0.00015850 | SELECT DATABASE()                                           |
|        4 | 0.01245925 | show tables                                                 |
|        5 | 0.00442350 | explain select * from score                                 |
|        6 | 0.00570150 | explain select * from student                               |
|        7 | 0.00038025 | explain select * from student where student_no=202012340110 |
|        8 | 0.00062775 | explain select * from student where class_no=1002           |
+----------+------------+-------------------------------------------------------------+
8 rows in set, 1 warning (0.00 sec)

mysql>
```







## explain

语法:

直接在select语句之前加上关键字 explain / desc

EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;



```sh
mysql> use student1;
Database changed
mysql> show tables;
+-------------------------+
| Tables_in_student1      |
+-------------------------+
| administrators          |
| administrators_password |
| class                   |
| course                  |
| forum                   |
| login_log               |
| news                    |
| score                   |
| student                 |
| student_password        |
| teach                   |
| teacher                 |
| teacher_password        |
+-------------------------+
13 rows in set (0.01 sec)

mysql> explain select * from score;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | score | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 7199 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from student;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from student where student_no=202012340110;
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | const | PRIMARY,no    | PRIMARY | 8       | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where class_no=1002;
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | class_no      | class_no | 8       | const |   60 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+----------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql>
```





说明：

* id： select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。
* select_type： 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等
* type ：表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。
* possible_key： 显示可能应用在这张表上的索引，一个或多个。
* key： 实际使用的索引，如果为NULL，则没有使用索引。
* key_len ：表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。
* rows ：MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。
* filtered 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。







# 索引使用

## 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。



address、id_card、email建立索引



```sh
mysql> explain select * from student where address="13";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where id_card="111";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where email="222";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" and id_card="1";
+----+-------------+---------+------------+------+---------------+--------+---------+-------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref         | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 245     | const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" and id_card="1" and email="111";
+----+-------------+---------+------------+------+---------------+--------+---------+-------------------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref               | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 368     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" and email="111";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |    10.00 | Using index condition |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where email="2" and address="1";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |    10.00 | Using index condition |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql>
```





## 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。

在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <





## 索引失效情况

### 索引列运算

不要在索引列上进行运算操作， 索引将失效。



例：

```sh
explain select * from tb_user where substring(phone,10,2) = '15'
```



### 字符串不加引号

字符串类型字段使用时，不加引号，索引将失效。



```sh
mysql> explain select * from student where address=0;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | index1        | NULL | NULL    | NULL |  600 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)

mysql> explain select * from student where address="0";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```





### 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效



```sh
mysql> explain select * from student where address="1";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address like "%1";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address like "1%";
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | index1        | index1 | 183     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address like "%1%";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |    11.11 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address like "1";
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | index1        | index1 | 183     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+--------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql>
```





### or连接条件

用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。



```sh
mysql> explain select * from student where address="1" and sex="1";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" or sex="1";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | index1        | NULL | NULL    | NULL |  600 |    19.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" or email="1";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | index1        | NULL | NULL    | NULL |  600 |    19.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" or id_card="1";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | index1        | NULL | NULL    | NULL |  600 |    19.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where address="1" or class_no=1001;
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table   | partitions | type        | possible_keys   | key             | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | student | NULL       | index_merge | class_no,index1 | index1,class_no | 183,8   | NULL |   61 |   100.00 | Using sort_union(index1,class_no); Using where |
+----+-------------+---------+------------+-------------+-----------------+-----------------+---------+------+------+----------+------------------------------------------------+
1 row in set, 1 warning (0.00 sec)

mysql>
```





### 数据分布影响

如果MySQL评估使用索引比全表更慢，则不使用索引。

就是因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。



```sh
mysql> explain select * from student where class_no>=1002;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | class_no      | NULL | NULL    | NULL |  600 |    90.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student where class_no>=1009;
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table   | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | student | NULL       | range | class_no      | class_no | 8       | NULL |  120 |   100.00 | Using index condition |
+----+-------------+---------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

mysql>

```







## SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。

* use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。

* ignore index ： 忽略指定的索引。
* force index ： 强制使用索引。



```sh
mysql> explain select * from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student use index(index_address) where address="1";
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index_address | index_address | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student ignore index(index_address,index1) where address="1";
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  600 |    10.00 | Using where |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student ignore index(index_address) where address="1";
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1        | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student ignore index(index1) where address="1";
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index_address | index_address | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from student force index(index_address) where address="1";
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index_address | index_address | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+---------------+---------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql>
```





## 覆盖索引

尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。



Extra含义：

* Using where; Using Index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据
* Using index condition：查找使用了索引，但是需要回表查询数据



```sh
mysql> explain select * from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select address,email from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | Using index |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select address,id_card from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | Using index |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select address,id_card,email from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | Using index |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select address,id_card,email,sex from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select sex from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select student_no from student where address="1";
+----+-------------+---------+------------+------+----------------------+---------------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys        | key           | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+----------------------+---------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index_address | 183     | const |    1 |   100.00 | Using index |
+----+-------------+---------+------------+------+----------------------+---------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select student_no,class_no from student where address="1";
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
| id | select_type | table   | partitions | type | possible_keys        | key    | key_len | ref   | rows | filtered | Extra |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | student | NULL       | ref  | index1,index_address | index1 | 183     | const |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+------+----------------------+--------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql>
```



因为，在student表中有一个联合索引index1，

该索引关联了三个字段 address、id_card、email，

而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主 键id。

所以当我们查询返回的数据在 id、 address、id_card、email 之中，则直接走二级索引直接返回数据了。

如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，这个过程就是回表。

而我们如果一直使用select * 查询返回所有字段值，很容易就会造成回表 查询（除非是根据主键查询，此时只会扫描聚集索引）。





## 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。



语法：

```sql
create index xxxx on table_name(column(n)) ;
```



```sh
mysql> create index index_email on student(email(5));
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> show index from student;
+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table   | Non_unique | Key_name      | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| student |          0 | PRIMARY       |            1 | student_no  | A         |         600 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| student |          1 | class_no      |            1 | class_no    | A         |          10 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| student |          1 | index1        |            1 | address     | A         |         600 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| student |          1 | index1        |            2 | id_card     | A         |         600 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| student |          1 | index1        |            3 | email       | A         |         600 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| student |          1 | index_address |            1 | address     | A         |         600 |     NULL |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
| student |          1 | index_email   |            1 | email       | A         |         600 |        5 |   NULL | YES  | BTREE      |         |               | YES     | NULL       |
+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
7 rows in set (0.00 sec)

mysql>
```





前缀长度：

可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。



```sh
select count(distinct email) / count(*) from student ;
select count(distinct substring(email,1,5)) / count(*) from student ;
```



```sh
mysql> select count(distinct email) / count(*) from student ;
+----------------------------------+
| count(distinct email) / count(*) |
+----------------------------------+
|                           1.0000 |
+----------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,5)) / count(*) from student ;
+-------------------------------------------------+
| count(distinct substring(email,1,5)) / count(*) |
+-------------------------------------------------+
|                                          1.0000 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,4)) / count(*) from student ;
+-------------------------------------------------+
| count(distinct substring(email,1,4)) / count(*) |
+-------------------------------------------------+
|                                          1.0000 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,3)) / count(*) from student ;
+-------------------------------------------------+
| count(distinct substring(email,1,3)) / count(*) |
+-------------------------------------------------+
|                                          0.9933 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,2)) / count(*) from student ;
+-------------------------------------------------+
| count(distinct substring(email,1,2)) / count(*) |
+-------------------------------------------------+
|                                          0.8000 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql> select count(distinct substring(email,1,1)) / count(*) from student ;
+-------------------------------------------------+
| count(distinct substring(email,1,1)) / count(*) |
+-------------------------------------------------+
|                                          0.0600 |
+-------------------------------------------------+
1 row in set (0.00 sec)

mysql>
```





## 单列索引与联合索引

* 单列索引：即一个索引只包含单个列。 

* 联合索引：即一个索引包含了多个列。



在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。





## 索引设计原则



* 针对于数据量较大，且查询比较频繁的表建立索引。
* 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
* 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
* 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
* 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。
* 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
* 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。







# SQL优化



## 插入数据

### insert

如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。



1. 批量插入数据

```sql
Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
```



2. 手动控制事务

```sql
start transaction;
insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
commit;
```



3. 主键顺序插入，性能要高于乱序插入

* 主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3 

* 主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89



### 大批量插入数据

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：



-- 客户端连接服务端时，加上参数 -–local-infile

```sh
mysql –-local-infile -u root -p
```



设置全局参数local_infile为1，开启从本地加载文件导入数据的开关

```sh
set global local_infile = 1;
```



执行load指令将准备好的数据，加载到表结构中

```sh
load data local infile '/root/sql1.log' into table tb_user fields
terminated by ',' lines terminated by '\n' ;
```



在load时，主键顺序插入性能高于乱序插入





## 主键优化

### 数据组织方式

在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。

行数据，都是存储在聚集索引的叶子节点上的。

在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。



### 页分裂

页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。



 主键顺序插入效果：

* 从磁盘中申请页， 主键顺序插入
* 第一个页没有满，继续往第一页插入
* 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接
* 当第二页写满了，再往第三页写入



主键乱序插入效果：

*  假如1,2页都已经写满了，存放了数据，第一页为1、5、9、23、47，第二页为55、67、89、101、107
* 此时再插入id为50的记录
* 按照顺序，应该存储在47之后
* 但是47所在的1页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3。
* 但是并不会直接将50存入3页，而是会将1页后一半的数据，移动到3页，然后在3页，插入50。
* 移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1的下一个 页，应该是3， 3#的下一个页是2。 所以，此时，需要重新设置链表指针。
* 上述的这种现象，称之为 "页分裂"，是比较耗费性能的操作。





### 页合并

现有3页数据：

第一页为1到8

第二页为9到16

第三页为17到19



当我们对已有数据进行删除时，具体的效果如下:

* 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。

* 当我们继续删除2号页的数据记录
* 当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。
* 二号页的数据只剩9到12，三号的数据为17到19，三号页的所有数据到二号页的所有数据的后面
* 再次插入新的数据21，则直接插入3号页
* 个里面所发生的合并页的这个现象，就称之为 "页合并"。



MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。



### 索引设计原则

* 满足业务需求的情况下，尽量降低主键的长度。
* 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
* 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
* 业务操作时，避免对主键的修改。





## order by优化

